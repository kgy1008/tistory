<h2>외부 트랜잭션과 내부 트랜잭션</h2>
<p>트랜잭션 전파란, 이미 진행 중인 트랜잭션이 존재할 때 추가로 트랜잭션을 수행하려는 상황에서 어떻게 동작할 지 결정하는 것을 트랜잭션 전파(propagation)이라고 한다. 트랜잭션 전파에는 여러가지 옵션이 존재하지만, 기본 옵션이 REQUIRED를 기준으로 설명하겠다.</p>
<p><figure class="imageblock alignCenter"><span><img height="467" src="https://blog.kakaocdn.net/dn/80KKL/btsMNejGvjZ/1f3O3zF5vwNQnEZPNdFTK0/img.png" width="2048" /></span></figure>
</p>
<p><b>외부 트랜잭션</b>이란 쉽게 말해서 가장 먼저 시작된 트랜잭션이다. 그리고 <b>내부 트랜잭션</b>은 그 이후에 호출된 트랜잭션으로 외부에 트랜잭션이 수행되고 있는 도중에 호출되기 때문에 마치 내부에 있는 것처럼 보여서 내부 트랜잭션이라 한다.</p>
<h3>흐름</h3>
<p>내부 트랜잭션을 시작하는 시점에는 이미 외부 트랜잭션이 진행중인 상태이다. 이 경우 내부 트랜잭션은 외부 트랜잭션에 참여한다. 즉, <b>내부 트랜잭션은 외부 트랜잭션을 기대로 이어 받아서 따른다</b>는 뜻이다. 때문에 내부 트랜잭션은 신규 트랜잭션이 아니다. 그저 이미 진행 중인 외부 트랜잭션에 참여하는 것이다. 내부 트랜잭션은 그저 참여하는 트랜잭션이기 때문에, 트랜잭션을 관리(롤백 또는 커밋)하는 것은 외부 트랜잭션이다. 정리하면, 스프링은 여러 트랜잭션이 함께 사용되는 경우, <b>처음 트랜잭션을 시작한 외부 트랜잭션이 실제 물리 트랜잭션을 관리</b>하는 것이다.</p>
<h2>물리 트랜잭션과 논리 트랜잭션</h2>
<p><figure class="imageblock alignCenter"><span><img height="269" src="https://blog.kakaocdn.net/dn/dnAQnR/btsMM6lLnIx/HPYHBxhY1WZNcv5SWSiAmK/img.png" width="623" /></span></figure>
</p>
<h3>물리 트랜잭션</h3>
<p>스프링은 이해를 돕기 위해 <b>논리 트랜잭션</b>과 <b>물리 트랜잭션</b>이라는 개념을 나눈다. <b>물리 트랜잭션</b>은 <b>실제 데이터베이스에 적용되는 트랜잭션</b>을 뜻한다. 즉, 실제 커넥션을 통해서 트랜잭션을 시작하고 커밋, 롤백하는 단위이다. 쉽게 말해 외부 트랜잭션과 내부 트랜잭션은 각각 논리 트랜잭션이고 이들을 하나로 묶어 물리 트랜잭션이라 부르는 것이다.</p>
<h3>논리 트랜잭션</h3>
<p><b>논리 트랜잭션</b>은 <b>트랜잭션 매니저를 통해 트랜잭션을 사용하는 단위</b>이다. <b>논리 트랜잭션</b>들은 하나의 물리 트랜잭션으로 묶인다. 이런 논리 트랜잭션 개념을 도입함으로써 여러 트랜잭션이 함께 사용되는 복잡한 상황에서도 아래와 같이 단순한 원칙을 적용할 수 있다.</p>
<ul>
<li><b>모든 논리 트랜잭션이 커밋되어야 물리 트랜잭션이 커밋된다.</b></li>
<li><b>하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션은 롤백된다.</b>&nbsp;</li>
</ul>
<p>정리하면, 트랜잭션 매니저를 통해 논리 트랜잭션을 관리하고, 모든 논리 트랜잭션이 커밋되면 물리 트랜잭션이 커밋되는 것이다.</p>
<h2>흐름</h2>
<p>개념에 대해 살펴보았으니 전체적인 흐름을 다시 한번 정리해보자.</p>
<h3>요청 흐름</h3>
<p><figure class="imageblock alignCenter"><span><img height="1000" src="https://blog.kakaocdn.net/dn/7VJmm/btsMOoZXOnL/rs6AobtuAwhow6Zx7CZmU0/img.png" width="1793" /></span></figure>
</p>
<p>트랜잭션 매니저를 통해, 외부 트랜잭션을 시작한다. 즉, 물리 트랜잭션이 시작되는 것이다. 트랜잭션 매니저는 생성된 커넥션을 트랜잭션 동기화 매니저에 보관한다, 이어 내부 트랜잭션이 호출된다. 트랜잭션 매니저는 트랜잭션 동기화 매니저를 통해서 기존 트랜잭션이 존재하는지 확인한다. 기존 트랜잭션이 존재하기 때문에 내부 트랜잭션은 기존의 외부 트랜잭션에 참여한다. 결과적으로 외부 트랜잭션에서 시작한 물리 트랜잭션의 범위가 내부 트랜잭션까지 사용된다.</p>
<h3>응답 흐름</h3>
<p><figure class="imageblock alignCenter"><span><img height="1000" src="https://blog.kakaocdn.net/dn/NLvSG/btsMNb8mYAX/xtcC6P01tTDx0V6kaptz0K/img.png" width="1750" /></span></figure>
</p>
<p>&nbsp;</p>
<p>내부 트랜잭션의 로직2가 모두 수행되면 트랜잭션 매니저를 통해 내부 트랜잭션을 커밋한다. 하지만, 내부 트랜잭션은 신규 트랜잭션이 아니기 때문에 물리 트랜잭션을 관리하지 않는다. 즉, 실제 커밋을 호출하지 않는다. 명심하자! <b>물리 트랜잭션은 외부 트랜잭션이 관리</b>하는 것이기 때문에, <b>외부 트랜잭션이 종료될 때까지 이어져야 한다.</b> 그 후, 외부 트랜잭션의 로직1이 모두 수행되면, 트랜잭션 매니저를 통해 외부 트랜잭션을 커밋한다. 외부 트랜잭션은 신규 트랜잭션이기 때문에 DB 커넥션에 실제 커밋을 호출하게 되고 물리 트랜잭션도 종료된다.</p>
<p>여기서 핵심은 <b>신규 트랜잭션(외부 트랜잭션)인 경우에만 실제 커넥션을 사용해서 물리 커밋과 롤백을 수행한다</b>는 점이다. 내부 트랜잭션은 물리 트랜잭션에 직접적으로 관여하지 않는다.</p>
<h3>내부 롤백</h3>
<p>우리는 하나의 논리 트랜잭션이라도 롤백되면 물리 트랜잭션이 롤백된다고 배웠다. 외부 트랜잭션에서 롤백이 발생한다면, 물리 트랜잭션에 물리 롤백을 수행하여 물리 트랜잭션을 롤백 시킬 수 있다. 그렇다면 물리 트랜잭션에 관여하지 않는 내부 트랜잭션에서 롤백이 발생했을 때, 어떻게 물리 트랜잭션이 롤백되는 것일까?</p>
<p><figure class="imageblock alignCenter"><span><img height="252" src="https://blog.kakaocdn.net/dn/bSfm4G/btsMMlDJQVU/8ed7rv6yibDqq3fmiebSdk/img.png" width="450" /></span></figure>
</p>
<p>위의 상황처럼 내부 트랜잭션을 롤백하면, 실제 물리 트랜잭션을 롤백하지는 못한다. 대신, 기존 트랜잭션을 롤백 전용으로 표시하여 롤백 대상이라는 일종의 마크를 남긴다. 응답 흐름을 자세히 살펴보자.</p>
<p><figure class="imageblock alignCenter"><span><img height="1000" src="https://blog.kakaocdn.net/dn/CbVCP/btsMM4uONdd/l50BeuqiKrh1DMXwKPnnok/img.png" width="1690" /></span></figure>
</p>
<p>내부 트랜잭션 로직에서 롤백이 발생하면, 앞서 말했듯이 실제 롤백을 호출하지 못한다. 이처럼 물리 트랜잭션을 롤백하지 않는 대신에 트랜잭션 동기화 매니저에 rollbackOnly=true라는 설정을 한다. 이후, 외부 트랜잭션 로직이 수행되고 커밋을 요청할 때, 트랜잭션 동기화 매니저에 롤백 전용 표시가 있는지 확인하고, 있다면 물리 트랜잭션을 커밋하는 것이 아니라 롤백하는 흐름으로 동작한다. 외부 트랜잭션 입장에서는 커밋을 했지만, 내부 트랜잭션의 롤백 전용 표시로 인해 롤백이 되어 버린 것이다. 때문에 UnexpectedRollbackException 런타임 예외를 던져 커밋을 시도했지만, 기대하지 않는 롤백이 발생했다는 것을 명확히 알려준다.</p>
<h2>전파 옵션</h2>
<p>지금까지는 기본 옵션인, REQUIRED를 기준으로 동작 과정에 대해서 알아보았다. 다시 한번 정리해보고 다른 옵션들에 대해서도 간략하게 알아보자.</p>
<h3>REQUIRED</h3>
<p>가장 많이 사용하는 기본 설정이다. 기존 트랜잭션이 없으면 생성하고, 있다면 기존 트랜잭션에 참여한다.</p>
<h3>REQUIRES_NEW</h3>
<p>이 옵션은 <b>외부 트랜잭션과 내부 트랜잭션을 완전히 분리하여 각각 별도의 물리 트랜잭션을 사용하는 방법</b>이다. 쉽게 말하면, 외부 트랜잭션과 내부 트랜잭션이 각각 별도의 물리 트랜잭션을 가지는 것이다.</p>
<p>&nbsp;</p>
<p><figure class="imageblock alignCenter"><span><img height="999" src="https://blog.kakaocdn.net/dn/NviSN/btsMM4Bvt4N/Gd5nHBmkNkmSkHfcF0Epc1/img.png" width="1712" /></span></figure>
</p>
<p>별도의 물리 트랜잭션을 가진다는 뜻은 서로 다른 DB 커넥션을 사용한다는 뜻이므로, 서로 다른 트랜잭션 2개가 동작한다고 생각하면 된다. 위 그림처럼, 트랜잭션 매니저는 REQUIRES_NEW 옵션일 때, 기존 트랜잭션에 참여하는 것이 아니라 새로운 트랜잭션을 시작한다. 때문에 내부 트랜잭션에서 롤백이 발생하면, 내부 트랜잭션 또한 신규 트랜잭션이기 때문에 실제 롤백을 호출하여 물리 트랜잭션을 롤백한다. 이때, 외부 트랜잭션과는 다른 물리 트랜잭션이므로 아무런 영향을 미치지 못한다.</p>
<p>정리하면, REQUIRES_NEW 옵션은 항상 새로운 트랜잭션을 생성한다. 기존 트랜잭션이 없다면, 새로운 트랜잭션을 생성하고 있어도 새로운 트랜잭션을 생성한다. 이처럼 REQUIRES_NEW 는 사용하는 DB 커넥션의 개수가 늘어나기 때문에 가급적 지양하는 것이 좋다. REQUIRES_NEW 를 사용하지 않고 문제를 해결할 수 있는 방법이 있다면 그 방법을 선택하자.</p>
<h3>SUPPORT</h3>
<p>말 그대로 트랜잭션을 지원한다는 뜻이다. 기존 트랜잭션이 없으면 트랜잭션 없이 진행하고, 있으면 참여한다.</p>
<h3>NOT_SUPPORT</h3>
<p>트랜잭션을 지원하지 않는다는 의미이다. 기존 트랜잭션 유무와 상관없이 트랜잭션 없이 진행한다.</p>
<h3>MANDATORY</h3>
<p>트랜잭션이 반드시 존재해야 한다. 만약 기존 트랜잭션이 없다면, IllegalTransactionStateException 예외가 발생하고 있다면, 기존 트랜잭션에 참여한다.</p>
<h3>NEVER</h3>
<p>MANDATORY와 반대로 트랜잭션을 사용하지 않는다는 의미이다. 이 경우에는, 기존 트랜잭션이 있으면 IllegalTransactionStateException 예외가 발생한다.</p>
<h3>NESTED</h3>
<p>기존 트랜잭션이 없을 경우, 새로운 트랜잭션을 생성하고 있을 경우, 중첩 트랜잭션을 만든다. 중첩 트랜잭션은 외부 트랜잭션의 영향을 받지만, 영향을 주지는 않는다. 즉, 중첩 트랜잭션이 롤백 되어도 외부 트랜잭션은 커밋할 수 있다. 하지만, 외부 트랜잭션이 롤백되면 중첩 트랜잭션도 함께 롤백된다. 하지만 JPA에서는 중첩 트랜잭션을 사용할 수 없다고 한다.</p>